# 2020 年面试准备

# css

## 盒模型

## 选择器

## 定位/浮动

## flex/grid

## 动画

# html

## 语义化

## 属性

## dom 操作

# js

## 模块化

### with

```js
function foo(obj1, obj2) {
  with (obj2) {
    console.log(obj1)
  }
}
foo('obj1', { obj1: 'obj2' })
foo('obj1', {})
```

with 指定的对象是作为作用域链的顶端

如果 with 执行块中只是用了指定对象的变量，那么减少了作用域链查找的长度

如果 with 执行块中用了作用域链上非顶端的变量，那么会加长了作用域链查找的长度

### node module.exports exports Common.js

可以这样理解：

在当前作用域提供了两个变量，module 和 exports

module.exports 和 exports 指向的是同一个对象地址

而最终 require 导入的是 module.exports

```js
// node.js
exports = { name: 'ccc' }
console.log(module.exports)
console.log(require('./node.js'))
// {}
// {}
```

exports 得到了一个新对象的地址，module.exports 指向的对象没有更改，require 导入的永远都是 module.exports

```js
// node.js
exports.name = 'ccc'
console.log(module.exports)
console.log(require('./node.js'))
// {name:'ccc'}
// {name:'ccc'}
```

exports 地址指向的对象添加了新的属性，module.exports 指向的对象发生了更改，require 导入的永远都是 module.exports

```js
// node.js
exports.name = 'ccc'
module.exports = 1
console.log(module.exports)
console.log(require('./node.js'))
// 1
// 1
```

exports 地址指向的对象添加了新的属性，module.exports 得到了一个新的值，require 导入的永远都是 module.exports

### es6 export export default

特点：静态分析，运行时不允许外部对引入的接口进行更改，当然接口的属性是可以修改的

::: 提示
import 会自动提升
:::

#### 1. export import

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
import { a, b } from './a.js'
```

上面 a.js 的导出，是导出指定名称的接口，不是值

而 b.js 是通过 {} 导入指定命名接口

#### 2. export import \*

整体加载

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
import * as a from './a.js'
console.log(a.a, 'a.a')
console.log(a.b, 'a.b')
```

#### 3. export default

默认输出，一个模块只能有一个默认输出

> 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。

```js
// a.js
export default function() {
  console.log('export defalut')
}
// b.js
import mode from './a.js'
console.log(mode)
```

export default 和 export 可以同时存在

```js
// a.js
export var a = 1
var b = 2
export { b }

export default function() {
  console.log('export defalut')
}

// b.js
import mode, { a, b } from './a.js'
console.log(mode, a, b)

// b.js
import mode from './a.js'
import { a, b } from './a.js'
console.log(mode, a, b)
```

#### 4. export from

export 和 import 的复合写法，先输入后输出

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
export { a, b } from './a.js'
```

#### 4. 跨模块常量小技巧

目录结构

- other.js
- constants
  - config.js
  - wx.js
  - index.js

常量分文件，再由 index 做转发

```js
// config.js
export const config = {
  baseUrl: 'https://blog.jschen.cc',
  port: '8080'
}
```

```js
// wx.js
export const wx = {
  appID: 1231231231231,
  Key: 12313123131
}
```

```js
// index.js
export { config } from './config.js'
export { wx } from './wx.js'
```

其他模块引入常量

```js
// other.js
import { config, wx } from './constants/index.js'
```

### es2020 提案 import() 动态加载

```js
const main = document.querySelector('main')

import(`./section-modules/${someVariable}.js`)
  .then(module => {
    module.loadPageInto(main)
  })
  .catch(err => {
    main.textContent = err.message
  })
```

> 这里直接抄阮一峰老师的[es6](https://es6.ruanyifeng.com/#docs/module#import)

### 区别

|      | es6 import                                                     | node require                             | es2020 import()                                       |
| ---- | -------------------------------------------------------------- | ---------------------------------------- | ----------------------------------------------------- |
| 特点 | 静态分析                                                       | 动态加载                                 | 动态加载                                              |
| 区别 | 编译时处理，所有无法实现运行时的动态加载，所以有一个提升的效果 | 到底加载的哪个模块，只有运行的时候才知道 | 运行是执行到哪就加载到哪，返回的是一个 `Promise` 对象 |

## 执行栈

## 原型链

## 闭包

## this

## new

## apply,cell,bind

### apply

es6

```js
Function.jschenApply = function (context,arr){
  context.fn = this
  return context.fn(...arr)
}
```

es3

```js
Function.jschenApply = function (context,arr){
  context.fn = this
  let args
  for (let i = 0; i < arr.length; i+=1) {
    args.push('arr[' + i + ']')
  }
  let result = eval('context.fn('+ args +')')
  delete context.fn
  return result
}
```

::: 重点
1. context 添加一个新的属性 fn ，让函数的 this 指向，context

2. 用 for 遍历 arr ,生成一个数组，元素为字符串型的引用语句，例如： 'arr[1]'

3. 使用 eval 函数执行函数

4. delete context.fn

5. 返回结果
:::

### call

```js
Function.prototype.jschenCall = function(context){
  context = context || window
  context.fn = this
  let result
  let args
  for (let i = 0; i < arguments.length; i+=1) {
    if(!i) return
    args.push('arguments[' + i +']')
  }
  result = eval('context.fn(' + args + ')')
  delete context.fn
  return result
}
```

::: 重点
1. context 添加一个新的属性 fn ，让函数的 this 指向，context

2. 用 for 遍历 arguments ,生成一个数组，元素为字符串型的引用语句，例如： 'arguments[1]'

3. 使用 eval 函数执行函数

4. delete context.fn

5. 返回结果
:::

### bind

es3简易版

```js
Function.prototype.jschenBind = function(context){
  let self = this
  let args1 = Array.prototype.slice.call(arguments,1)
  return function(){
    let args2 = Array.prototype.slice.call(arguments)
    return self.apply(context,args1.concat(args2))
  }
}
```

::: 重点
1. 把函数存为变量 self

2. 拿到剩余参数 

3. 拿到参数 

4. 使用 apply 执行函数

5. 返回结果
:::

## event-loop

## react vue 的区别

## webpack 的生命周期

## webpack 的 loader 和 plugin 阶段那个更耗时

## 如何用 var 实现 let const

## 防抖 节流

### 防抖

```js
function debounce (fn,time,immediate) {
  let timer = null
  let result
  return function (...val){
    clearTimeout(timer)
    if(immediate){
      if (!timer) {
        result = fn.apply(this,val)
      }
      timer = setTimeout(() => {
        timer = null
      },time * 1000)
    } else {
      timer = setTimeout(() => {
        result = fn.apply(this,val)
      },time * 1000)
    }
    return result
  }
}
```

### 节流

简单版本

```js
function throttle(fn,s){
  let result
  let start = 0
  return function (...val){
    if(+new Date > start + s*1000) {
      result = fn.apply(this,val)
      start = + new Date()
    }
    return result
  }
}
```




## promise

Promise 是 ES6 新增的语法，解决了回调地狱的问题。

## Proxy

代理

```js
var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
    console.log(`getting ${propKey}!`);
    return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
    console.log(`setting ${propKey}!`);
    return Reflect.set(target, propKey, value, receiver);
  }
});
obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
```



## 垃圾回收

v8 采用的是标记清除算法和标记压缩算法

v8 将内存（堆）分为新生代和老生代两部分



## 设计模式

### 工厂模式

### 单例模式

### 发布订阅

### 代理模式

###

# vue

## 响应式原理

# nuxt

## 浏览器渲染和服务端渲染的区别

# tcp/ip

## 状态码

### 永久重定向和临时重定向的区别

301 永久
302 临时
304 未修改，直接拿缓存

## http 缓存类型 ssl 加密

## http 和 https 的区别

node 服务器实现 http2

拉一个 node-http2 模块

```js
```

## https 配置安全证书 ssl 流程

首先介绍一下两个端口， 一个是 80 端口，一个是 443 端口

443 ： 网页浏览端口，主要是用于 HTTPS 服务，是提供加密和通过安全端口传输的另一种 HTTP。

80 ： 用于网页浏览。木马 Executor 开放此端口

### 用 node 做服务端，配置 ssl 流程

1. 到阿里云申请 ssl 证书
2. 下载 ssl 证书 nginx 版就可以，key 文件和 pem 文件
3. node 创建 https 文件，放入 key 文件和 pem 文件

```js
const express = require('express')
const http = require('http')
const https = require('https')
const fs = require('fs')
// Configuare https
const httpsOption = {
  key: fs.readFileSync('./https/xxxxxxxxxxxx.key'),
  cert: fs.readFileSync('./https/xxxxxxxxxxxx.pem')
}
// Create service
const app = express()

http.createServer(app).listen(80)
https.createServer(httpsOption, app).listen(443)
```

## [从输入 URL 到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)

- 重定向
- 拉取缓存
- DNS 查询
- 建立 TCP 链接
- 发起请求
- 接收响应
- 处理 HTML 元素
- 元素加载完成

## 跨域

# node

## cors

node 设置 cors

```js
app.use(function(req, res, next) {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTION')
  res.header('Access-Control-Allow-Headers', 'content-type,Origin,Accept,X-Requested-with,Access-Control-Allow-Credentials')
  res.header('Access-Control-Allow-Credentials', true)
  if (req.method == 'OPTION') {
    res.send(200)
  } else {
    next()
  }
})
```

# webpack

# CI/CD

# 测试

## 单元测试

## 端对端测试

# 性能优化

# 如何封装树状菜单


# 封装继承多态

```js
var a = 9
function fn() {
  a = 0
  return function(b) {
    return b + a++
  }
}

var f = fn()
console.log(f(5))
console.log(fn()(5))
console.log(f(5))
console.log(a)
```
