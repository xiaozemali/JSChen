# 2020 年面试准备

## css

### [BFC 块级格式化上下文](/pages/technology/architect/base/css.html#bfc-块级格式化上下文)

### [层叠上下文 stacking context](/pages/technology/architect/base/css.html#层叠上下文-stacking-context)

### [网格布局 grid](/pages/technology/architect/base/css.html#网格布局-grid-不常用)

### [盒模型](/pages/technology/architect/base/css.html#盒模型)

### [弹性布局 flex](/pages/technology/architect/base/css.html#弹性布局-flex)

### [containing block 包含块](/pages/technology/architect/base/css.html#containing-block-包含块)

### [选择器](/pages/technology/architect/base/css.html#选择器)

### [清除浮动](/pages/technology/architect/base/css.html#清除浮动)

### [动画](/pages/technology/architect/base/css.html#动画)

### [BEM 命名规范](/pages/technology/architect/base/css.html#bem-命名规范)

## html

### [语义化](/pages/technology/architect/base/html.html#语义化)

### [属性](/pages/technology/architect/base/html.html#属性)

### [dom 操作](/pages/technology/architect/base/html.html#dom-操作)

## js

### [模块化](/pages/technology/architect/base/export.html#模块化)

#### node module.exports exports Common.js

可以这样理解：

在当前作用域提供了两个变量，module 和 exports

module.exports 和 exports 指向的是同一个对象地址

而最终 require 导入的是 module.exports

```js
// node.js
exports = { name: 'ccc' }
console.log(module.exports)
console.log(require('./node.js'))
// {}
// {}
```

exports 得到了一个新对象的地址，module.exports 指向的对象没有更改，require 导入的永远都是 module.exports

```js
// node.js
exports.name = 'ccc'
console.log(module.exports)
console.log(require('./node.js'))
// {name:'ccc'}
// {name:'ccc'}
```

exports 地址指向的对象添加了新的属性，module.exports 指向的对象发生了更改，require 导入的永远都是 module.exports

```js
// node.js
exports.name = 'ccc'
module.exports = 1
console.log(module.exports)
console.log(require('./node.js'))
// 1
// 1
```

exports 地址指向的对象添加了新的属性，module.exports 得到了一个新的值，require 导入的永远都是 module.exports

#### es6 export export default

特点：静态分析，运行时不允许外部对引入的接口进行更改，当然接口的属性是可以修改的

::: 提示
import 会自动提升
:::

##### 1. export import

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
import { a, b } from './a.js'
```

上面 a.js 的导出，是导出指定名称的接口，不是值

而 b.js 是通过 {} 导入指定命名接口

##### 2. export import \*

整体加载

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
import * as a from './a.js'
console.log(a.a, 'a.a')
console.log(a.b, 'a.b')
```

##### 3. export default

默认输出，一个模块只能有一个默认输出

> 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。

```js
// a.js
export default function() {
  console.log('export defalut')
}
// b.js
import mode from './a.js'
console.log(mode)
```

export default 和 export 可以同时存在

```js
// a.js
export var a = 1
var b = 2
export { b }

export default function() {
  console.log('export defalut')
}

// b.js
import mode, { a, b } from './a.js'
console.log(mode, a, b)

// b.js
import mode from './a.js'
import { a, b } from './a.js'
console.log(mode, a, b)
```

##### 4. export from

export 和 import 的复合写法，先输入后输出

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
export { a, b } from './a.js'
```

##### 4. 跨模块常量小技巧

目录结构

- other.js
- constants
  - config.js
  - wx.js
  - index.js

常量分文件，再由 index 做转发

```js
// config.js
export const config = {
  baseUrl: 'https://blog.jschen.cc',
  port: '8080'
}
```

```js
// wx.js
export const wx = {
  appID: 1231231231231,
  Key: 12313123131
}
```

```js
// index.js
export { config } from './config.js'
export { wx } from './wx.js'
```

其他模块引入常量

```js
// other.js
import { config, wx } from './constants/index.js'
```

#### es2020 提案 import() 动态加载

```js
const main = document.querySelector('main')

import(`./section-modules/${someVariable}.js`)
  .then(module => {
    module.loadPageInto(main)
  })
  .catch(err => {
    main.textContent = err.message
  })
```

> 这里直接抄阮一峰老师的[es6](https://es6.ruanyifeng.com/#docs/module#import)



### with

```js
function foo(obj1, obj2) {
  with (obj2) {
    console.log(obj1)
  }
}
foo('obj1', { obj1: 'obj2' })
foo('obj1', {})
```

with 指定的对象是作为作用域链的顶端

如果 with 执行块中只是用了指定对象的变量，那么减少了作用域链查找的长度

如果 with 执行块中用了作用域链上非顶端的变量，那么会加长了作用域链查找的长度#### 区别

|      | es6 import                                                     | node require                             | es2020 import()                                       |
| ---- | -------------------------------------------------------------- | ---------------------------------------- | ----------------------------------------------------- |
| 特点 | 静态分析                                                       | 动态加载                                 | 动态加载                                              |
| 区别 | 编译时处理，所有无法实现运行时的动态加载，所以有一个提升的效果 | 到底加载的哪个模块，只有运行的时候才知道 | 运行是执行到哪就加载到哪，返回的是一个 `Promise` 对象 |



### 执行栈

### 原型链

### 闭包

### this

### new

### apply,cell,bind

#### apply

es6

```js
Function.prototype.jschenApply = function(context, arr) {
  context.fn = this
  return context.fn(...arr)
}
```

es3

```js
Function.prototype.jschenApply = function(context, arr) {
  context.fn = this
  let args
  for (let i = 0; i < arr.length; i += 1) {
    args.push('arr[' + i + ']')
  }
  let result = eval('context.fn(' + args + ')')
  delete context.fn
  return result
}
```

::: 重点

1. context 添加一个新的属性 fn ，让函数的 this 指向，context

2. 用 for 遍历 arr ,生成一个数组，元素为字符串型的引用语句，例如： 'arr[1]'

3. 使用 eval 函数执行函数

4. delete context.fn

5. 返回结果
   :::

#### call

```js
Function.prototype.jschenCall = function(context) {
  context = context || window
  context.fn = this
  let result
  let args
  for (let i = 0; i < arguments.length; i += 1) {
    if (!i) return
    args.push('arguments[' + i + ']')
  }
  result = eval('context.fn(' + args + ')')
  delete context.fn
  return result
}
```

::: 重点

1. context 添加一个新的属性 fn ，让函数的 this 指向，context

2. 用 for 遍历 arguments ,生成一个数组，元素为字符串型的引用语句，例如： 'arguments[1]'

3. 使用 eval 函数执行函数

4. delete context.fn

5. 返回结果
   :::

#### bind

es3 简易版

```js
Function.prototype.jschenBind = function(context) {
  let self = this
  let args1 = Array.prototype.slice.call(arguments, 1)
  return function() {
    let args2 = Array.prototype.slice.call(arguments)
    return self.apply(context, args1.concat(args2))
  }
}
```

::: 重点

1. 把函数存为变量 self

2. 拿到剩余参数

3. 拿到参数

4. 使用 apply 执行函数

5. 返回结果
   :::

### event-loop

| 宏任务                | 浏览器 | node | 备注                               |
| --------------------- | ------ | ---- | ---------------------------------- |
| setTimeout            | ✅     | ✅   |                                    |
| setInterval           | ✅     | ✅   |                                    |
| setImmediate          | ❌     | ✅   |                                    |
| requestAnimationFrame | ✅     | ❌   | 请求下次重绘前调用回调函数更新动画 |
| I/O                   | ✅     | ✅   |                                    |

| 微任务           | 浏览器 | node | 备注                      |
| ---------------- | ------ | ---- | ------------------------- |
| process.nextTick | ❌     | ✅   |                           |
| promise          | ✅     | ✅   |                           |
| MutationObserver | ✅     | ❌   | 监听指定 dom 更改后的回调 |

### cookie localStorage sessionStorage indexDB

| 特性         | cookie                                     | localStorage             | sessionStorage | indexDB                  |
| ------------ | ------------------------------------------ | ------------------------ | -------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间         | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                                         | 5M                       | 5M             | 无限                     |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与                   | 不参与         | 不参与                   |




### Service Worker

用于浏览器缓存，vue 文档就有用

具体看这篇博文[前端进阶之道](https://www.yuchengkai.cn/docs/frontend/browser.html#service-worker)

### react vue 的区别

### webpack 的生命周期

### webpack 的 loader 和 plugin 阶段那个更耗时

### 如何用 var 实现 let const

### 防抖 节流

#### 防抖

```js
function debounce(fn, time, immediate) {
  let timer = null
  let result
  return function(...val) {
    clearTimeout(timer)
    if (immediate) {
      if (!timer) {
        result = fn.apply(this, val)
      }
      timer = setTimeout(() => {
        timer = null
      }, time * 1000)
    } else {
      timer = setTimeout(() => {
        result = fn.apply(this, val)
      }, time * 1000)
    }
    return result
  }
}
```

#### 节流

简单版本

```js
function throttle(fn, s) {
  let result
  let start = 0
  return function(...val) {
    if (+new Date() > start + s * 1000) {
      result = fn.apply(this, val)
      start = +new Date()
    }
    return result
  }
}
```

### promise

Promise 是 ES6 新增的语法，解决了回调地狱的问题。

### Proxy

代理

```js
var obj = new Proxy(
  {},
  {
    get: function(target, propKey, receiver) {
      console.log(`getting ${propKey}!`)
      return Reflect.get(target, propKey, receiver)
    },
    set: function(target, propKey, value, receiver) {
      console.log(`setting ${propKey}!`)
      return Reflect.set(target, propKey, value, receiver)
    }
  }
)
obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
```

### 垃圾回收

v8 采用的是标记清除算法和标记压缩算法

v8 将内存（堆）分为新生代和老生代两部分

### 设计模式

#### 工厂模式

#### 单例模式

#### 发布订阅

#### 代理模式

###

## vue

### 响应式原理

利用了 object.definedProperty 实现一个观察者，和数据代理

再通过一个发布订阅模式，在数据更改时通知所有订阅者，在初始化订阅者的时候把当前订阅者缓存起来，并且强制执行监听器的 get 函数

再来一个订阅器做保存当前订阅者用

匹配 `{{}}` 实现一个编译器


### 路由

三种

- hash
- history
- abstract

#### hash

- hash 其实就是锚点，跳转到锚点指定的位置而不会真的跳转页面

- 通过监听 hashchange 做页面更换处理

#### history

- 利用 html5 history 维护一个页面栈

- 路由跳转实际上并不是真的跳转页面，需要在服务端配置重定向

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="jschen"></div>
  <ul>
    <li href="/cc1">ccc1</li>
    <li href="/cc2">ccc2</li>
    <li href="/cc3">ccc3</li>
  </ul>
</body>
<script>
  class Router {
    constructor(){
      this.router = {}
    }
    push(url,query){
      history.pushState({query},'title_cc1',url)
      this.router[url] && this.router[url]()
    }
    replace(url,query){
      history.replaceState({query,},'title_cc1',url)
      this.router[url] && this.router[url]()
    }
    init(...val){
      this.replace(...val)
    }
    setConfig(optionList){
      optionList.forEach(pageOption => {
        this.router[pageOption.router] = pageOption.cb // 这个cb就是用来切换页面的 
      });
    }
  }
  let router = new Router()
  router.setConfig([
    {
      router:'/html.html',
      cb:() => {console.log('加载主页')}
    },
    {
      router:'/cc1',
      cb:() => {console.log('加载cc1')}
    },
    {
      router:'/cc2',
      cb:() => {console.log('加载cc2')}
    },
    {
      router:'/cc3',
      cb:() => {console.log('加载cc3')}
    }
  ])
  router.init(location.pathname,{name:'我是主页'}) // 这里很重要哈，因为history模式下跳转的页面实际上是不存在的，如果用户在其他路由下刷新页面那么nginx接到的请求页面是找不到的，所以这里需要在nginx配置重定向
  document.querySelector('ul').addEventListener('click',(e) => {
    console.log(e,'e');
    e.preventDefault()
    console.log(e.target.getAttribute('href'));
    
    router.push(e.target.getAttribute('href'),{name:'asdf'})
  })
</script>
</html>
```


#### abstract

这个是在 node.js 跑的

## nuxt

### 浏览器渲染和服务端渲染的区别

## tcp/ip

### 状态码

#### 永久重定向和临时重定向的区别

301 永久
302 临时
304 未修改，直接拿缓存

401 未授权
404 找不到
412 未满足前提条件

500 服务端错误

### http 缓存类型 ssl 加密

### http 和 https 的区别

node 服务器实现 http2

拉一个 node-http2 模块

```js
```

### https 配置安全证书 ssl 流程

首先介绍一下两个端口， 一个是 80 端口，一个是 443 端口

443 ： 网页浏览端口，主要是用于 HTTPS 服务，是提供加密和通过安全端口传输的另一种 HTTP。

80 ： 用于网页浏览。木马 Executor 开放此端口

#### 用 node 做服务端，配置 ssl 流程

1. 到阿里云申请 ssl 证书
2. 下载 ssl 证书 nginx 版就可以，key 文件和 pem 文件
3. node 创建 https 文件，放入 key 文件和 pem 文件

```js
const express = require('express')
const http = require('http')
const https = require('https')
const fs = require('fs')
// Configuare https
const httpsOption = {
  key: fs.readFileSync('./https/xxxxxxxxxxxx.key'),
  cert: fs.readFileSync('./https/xxxxxxxxxxxx.pem')
}
// Create service
const app = express()

http.createServer(app).listen(80)
https.createServer(httpsOption, app).listen(443)
```

### [从输入 URL 到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)

- 重定向
- 拉取缓存
- DNS 查询
- 建立 TCP 链接
- 发起请求
- 接收响应
- 处理 HTML 元素
- 元素加载完成

### 跨域

## node

### cors

node 设置 cors

```js
app.use(function(req, res, next) {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTION')
  res.header('Access-Control-Allow-Headers', 'content-type,Origin,Accept,X-Requested-with,Access-Control-Allow-Credentials')
  res.header('Access-Control-Allow-Credentials', true)
  if (req.method == 'OPTION') {
    res.send(200)
  } else {
    next()
  }
})
```

## webpack

## CI/CD

## 测试

### 单元测试

### 端对端测试

## 性能优化

- window.serviceWorker 缓存文件

- 越是具体的 CSS 选择器，执行速度越慢

- 频繁的单独生成图层
  - 3D 变换：translate3d、translateZ
  - will-change
  - video、iframe 标签
  - 通过动画实现的 opacity 动画转换
  - position: fixed

- 减少重绘和回流[前端进阶之道](https://www.yuchengkai.cn/docs/frontend/browser.html#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81)

- DNS 预解析[MDN  X-DNS-Prefetch-Control](https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching)
- 强缓存和协商缓存
- http2.0
- webpack 设置 tree shaking 移除没有用的代码

## 安全




## 如何封装树状菜单

## 封装继承多态

```js
var a = 9
function fn() {
  a = 0
  return function(b) {
    return b + a++
  }
}

var f = fn()
console.log(f(5))
console.log(fn()(5))
console.log(f(5))
console.log(a)
```

## 同源策略，跨域规避方案

### 一、一级域名相同 -- 拿 `cookie`

`A` 网页 `https://xiaoai.dankal.cn` ， `B` 网页 `https://xiaoai-admin.dankal.cn` ， `C` 网页 `https://dankal.cn` ， `AB` 网页都是二级域名 ， `C` 网页是顶级域名

3 个分别窗口访问 `A` 、 `B` 、 `C` ， 或者 互相嵌入 `iframe`

通过设置 `cookie` 规避跨域

```js
// 在任意页面
document.cookie = "test=i'm test cookie;domain=dankal.cn"
```

```js
// 在任意页面
document.cookie
// test=i'm test cookie
```

### 二、 一级域名相同 -- 内嵌 `iframe` -- 拿 `DOM`

`A` 网页 `https://xiaoai.dankal.cn` ， `iframe` 页面 `https://xiaoai-admin.dankal.cn` ，

设置 `A` 页面和 `iframe` 页面的 `domain` 为顶级域名 `dankal.cn`

```js
//  `A` 页面和 `iframe` 页面
document.domain = 'dankal.cn'
```

```js
// `A` 页面
document.getElementById('iframeId').contentWindow.document
// # document
```

```js
// iframe 页面
window.parent.document
// # document
```

### 三、 postMessage

父亲向子发消息

```js
// 父窗口
var jschenP = window.open('https://www.baidu.cn')
jschenP.postMessage('hello baidu', 'https://www.baidu.cn')

// 百度
window.addEventListener('message', function(event) {
  console.log(event.data) // 消息内容
  console.log(event.origin) // 发消息的网站
  console.log(event.source) // 发消息的窗口
})
```

子向父亲发消息

```js
// 父窗口 https://blog.jschen.cc
var jschenP = window.open('https://www.baidu.cn')
window.addEventListener('message', function(event) {
  console.log(event.data) // 消息内容
  console.log(event.origin) // 发消息的网站
  console.log(event.source) // 发消息的窗口
})

// 百度
window.opener.postMessage('hello father', 'https://blog.jschen.cc')
```

### 四、ajax 请求 jsonp ， websocket ， cors

#### jsonp

```js
function foo(data) {
  console.log(data, '成功拿到数据了')
}
function getApi(src) {
  let script = document.createElement('script')
  script.src = src
  document.body.appendChild(script)
}
window.onload = function() {
  getApi('https://www.baidu.com?callback=foo')
}
```

#### webSocket

使用 ws wss 协议标识符，在 tcp 协议上进行全双工通讯

这里偷偷摘了阮一峰老师[WebSocket](http://www.ruanyifeng.com/blog/2017/05/websocket.html)的 wss 地址

```js
var websocket = new WebSocket('wss://echo.websocket.org')

websocket.onopen = function(evt) {
  console.log('Connection 开了 ...')
  websocket.send('Hello WebSockets!')
}

websocket.onmessage = function(evt) {
  console.log('Received 接受到的消息: ' + evt.data)
  this.send(evt.data)
}

websocket.onclose = function(evt) {
  console.log('Connection closed.')
}

websocket.send('我是 JSChen！')
```

#### node 设置 cors

```js
app.use('*', (req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTION')
  res.header('Access-Control-Allow-Headers', 'content-type,Cache-Control,Access-Control-Allow-Credentials')
  res.header('Access-Control-Allow-Credentials', true)
  if (req.methods == 'OPTION') {
    res.send(200)
  } else {
    next()
  }
})
```


