# 2020 年面试准备

## css

### BFC 块级格式化上下文

块级格式化上下文： `东西` （指的就是这个抽象的 `东西` ）通过设置特定属性而成

**变身块级格式化上下文**

[MDN--格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)

::: tip 常用的
- html
- float
- position: fixed/absolute
- display: inline-block/table-cell/table-caption ...
- overflow 值不为 visible 的块元素
- **display: flow-root**(创建无副作用的BFC)
- contain: layout/content/paint
- **display: flex/inline-flex 的子元素**
- **display: grid/inline-grid 的子元素**
:::

特点：内部元素不会影响到外部元素，

### 层叠上下文 stacking context

- 层叠上下文： `东西` （指的就是这个抽象的 `东西` ）通过设置特定属性而成

- 层叠水平：`位置`（指定就是 `所有元素` 包括 `层叠上下文` 这个东西的 `位置`）

- 层叠顺序：`顺序`（指定就是 `所有元素` 包括 `层叠上下文` 这个东西 `位置`的顺序，也就是 `规则` ）


**变身为层叠上下文**

[MDN--层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)

**层叠顺序**

- 高层叠低层

- 同层后来居上

**七层顺序**

1. 层叠上下文

2. 负z-index(这个元素本身也是一个层叠上下文，是 `1` 的子元素、子层叠上下文)

3. block

4. float

5. inline、inline-block

6. z-index:auto/0 

  * z-index:auto

  * z-index:0(这个元素本身也是一个层叠上下文，是 `1` 的子元素、子层叠上下文)

  * opacity/transform/mix-blend-mode/filter/isolation:isolate/will-change/flex子元素

7. z-index:正(这个元素本身也是一个层叠上下文，是 `1` 的子元素、子层叠上下文)


### 网格布局 grid



## 盒模型

- 标准盒子模型
- 怪异盒子模型（ie）

```html
<div style="margin:10px;border:10px solid yellow;padding:10px;width:100px;height:100px;background:red;"></div>
```
<div style="width:100px;height:100px;background:red;"> 100 * 100</div>
<div style="margin:10px;border:10px solid yellow;padding:10px;width:100px;height:100px;background:red;box-sizing:border-box"></div>

上面这个盒子在w3c标准盒子模型和IE的怪异盒子模型（ie）下面分别的宽度

```css
标准盒子模型：总宽度 = content 100px + border 10px * 2 + padding 10px * 2 + margin 10px * 2 //160px
怪异盒子模型: 总宽度 = (content 60px + border 10px * 2 + padding 10px * 2) +  margin 10px * 2// 120px
```

可以通过 css3 属性 `box-sizing` 来切换

也就是说 `ie` 盒模型相当于 `标准盒模型` 设置了 `box-sizing: border-box;`

::: tip box-sizing
`box-sizing： content-box || border-box`

`border-box` 将使用怪异盒子模型（ie）
当怪异盒子模型（ie）的宽度小于 `border+padding` 的宽度的时候， `content width` 将变为 `0` ，盒子的宽度会被 `border + padding` 的总宽度撑开
:::




## 弹性布局 flex

传统的 block 元素，采用的是垂直方向布局，inline 元素水平方向布局，而 flex 内在没有方向限制

## containing block 包含块

子元素的百分比，比较的是父元素的 `containing block`


<style>
    .parent{
        padding:50px;
        border:50px solid green;
        width:200px;
        height:200px;
        background:red;
    }
    .child{
        width:80%;
        height:80%;
        background:yellow;
    }
    .parent--e1{
        box-sizing:border-box;
    }
    .parent--e2{
        box-sizing:content-box;
    }
    .parent--e3{
        position:relative;
        box-sizing:border-box;
    }
    .child--e3{
        position:absolute;
    }
    .parent--e4{
        position:relative;
        box-sizing:content-box;
    }
</style>

1. containing block = 宽高减去padding和border = 0 0
<div class="parent parent--e1">
 <div class="child"></div>
</div>


```html
<div class="parent parent--e1">
 <div class="child"></div>
</div>
<style>
    .parent{
        padding:50px;
        border:50px solid green;
        width:200px;
        height:200px;
        background:red;
    }
    .child{
        width:80%;
        height:80%;
        background:yellow;
    }
    .parent--e1{
        box-sizing:border-box;
    }
    .parent--e2{
        box-sizing:content-box;
    }
    .parent--e3{
        position:relative;
        box-sizing:border-box;
    }
    .child--e3{
        position:absolute;
    }
    .parent--e4{
        position:relative;
        box-sizing:content-box;
    }
</style>
```


2. containing block = 宽高 = 200 200

<div class="parent parent--e2">
 <div class="child"></div>
</div>

```html
<div class="parent parent--e2">
 <div class="child"></div>
</div>
```


3. containing block = padding area = 宽高减去border = 100 100（特殊情况）

<div class="parent parent--e3">
 <div class="child child--e3"></div>
</div>

```html
<div class="parent parent--e3">
 <div class="child child--e3"></div>
</div>
```
4. containing block = padding area = 宽高加padding = 250 250（特殊情况）

<div class="parent parent--e4">
 <div class="child child--e3"></div>
</div>

```html
<div class="parent parent--e4">
 <div class="child child--e3"></div>
</div>
```

### 选择器

- id选择器
- 标签选择器
- class选择器
- 相邻选择器
- 子选择器
- 后代选择器
- 通配符选择器
- 属性选择器
- 伪类选择器

### 清除浮动

1. 最后一个元素设置 `display:block;clear:both`

2. 设置父元素为 `BFC`

### 动画



## html

### 语义化

### 属性

#### title 和 alt 的区别

```html
<img src="#" alt="alt信息" />
```
当图片不输出信息的时候，会显示alt信息 鼠标放上去没有信息，当图片正常读取，不会出现alt信息

```html
<img src="#" alt="alt信息" title="title信息" />
```

当图片不输出信息的时候，会显示alt信息,鼠标放上去会出现title信息

当图片正常输出的时候，不会出现alt信息，鼠标放上去会出现title信息

::: tip title
title属性可以用在除了base，basefont，head，html，meta，param，script和title之外的所有标签
`title属性的功能是提示`。额外的说明信息和非本质的信息请使用title属性。title属性值可以比alt属性值设置的更长
title属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。

:::

### dom 操作

#### addEventListener

事件机制、事件流、事件传播

- 冒泡
- 捕获

1. 冒泡，从 `dom` 树 `指定层` 往 `上层` 追溯

```js
// 默认false 冒泡
node.addEventListener(
  'click',
  function() {
    alert('我是冒泡')
  },
  false
)
```

冒泡的终点，window，下面引入 [wayne zhu 的一篇博文](https://www.cnblogs.com/zhuzhenwei918/p/6139880.html)

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JSChen</title>
  </head>
  <body>
    <div id="first">
      <div id="second">
        <button id="button">冒泡</button>
      </div>
    </div>
    <script>
      var button = document.getElementById('button'),
        second = document.getElementById('second'),
        first = document.getElementById('first'),
        body = document.body,
        html = document.documentElement
      button.addEventListener('click', function() {
        alert('button')
      })
      second.addEventListener('click', function() {
        alert('second')
      })
      first.addEventListener('click', function() {
        alert('first')
      })
      body.addEventListener('click', function() {
        alert('body')
      })
      html.addEventListener('click', function() {
        alert('html')
      })
      window.addEventListener('click', function() {
        alert('window')
      })
    </script>
  </body>
</html>
```

`button -> div1 -> div2 -> body -> html -> window`。 即最终可以冒泡到 window 上，即使是有 iframe 的话，也是不影响的，比如，我们把这个页面嵌入到另外一个页面中， 最终也是会冒泡到这个页面的 window，即使是在 iframe 上添加一个 click 事件，也是不会冒泡到这个 iframe 上的，即事件的冒泡是相互独立的。

2. 捕获，从 `dom` 树 `上层` 往 `指定层` 追溯

```js
// 设置true 捕获
node.addEventListener(
  'click',
  function() {
    alert('我是冒泡')
  },
  true
)
```

3. 阻止冒泡和捕获 `stopPropagation` 、 `stopImmediatePropagation` 两种

stopPropagation， stopImmediatePropagation 都可以阻止冒泡和捕获，但是 stopImmediatePropagation 是把指定元素剩下的同类型的的事件和追溯下去的事件都阻止掉

**`(1). stopPropagation`**

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>JSChen</title>
    <style>
      #myDiv {
        background-color: coral;
        border: 1px solid;
        padding: 50px;
      }
    </style>
  </head>
  <body>
    <p>该实例演示了在添加事件监听时冒泡与捕获阶段的不同。</p>
    <div id="myDiv">
      <p id="myP">点击该段落， 我是冒泡</p>
    </div>
    <br />
    <script>
      document.getElementById('myP').addEventListener('click', function() {
        event.stopPropagation()
        alert('你点击了 P 元素!')
      })
      document.getElementById('myP').addEventListener('click', function() {
        alert('你点击了 P2 元素!')
      })
      document.getElementById('myDiv').addEventListener('click', function() {
        alert('你点击了 DIV 元素!')
      })
      document.getElementById('myP2').addEventListener(
        'click',
        function() {
          alert('你点击了 P 元素!')
          event.stopImmediatePropagation()
        },
        true
      )
    </script>
  </body>
</html>
```

<html>
<head>
<meta charset="utf-8">
<title>JSChen</title>
<style>
#myDiv{
    background-color: coral;
    border: 1px solid;
    padding: 50px;
}
</style>
</head>
  <body>
    <div id="myDiv">
      <p id="myP">点击该段落， 我是冒泡</p>
    </div><br>
    <script>
      document.getElementById("myP").addEventListener("click", function() 
      {
        event.stopPropagation();
          alert("你点击了 P 元素!");
      });
      document.getElementById("myP").addEventListener("click", function() 
      {
          alert("你点击了 P2 元素!");
      });
      document.getElementById("myDiv").addEventListener("click", function()
      {
          alert("你点击了 DIV 元素!");
      });
      document.getElementById("myP2").addEventListener("click", function() 
      {
          alert("你点击了 P 元素!");
        event.stopImmediatePropagation()
      },true);
    </script>
  </body>
</html>

指定元素 myP 绑定的两个事件都可以触发，并且阻止了向外层冒泡

**`(2). stopImmediatePropagation`**

```html
<html>
  <head>
    <meta charset="utf-8" />
    <title>JSChen</title>
    <style>
      #myDiv2 {
        background-color: yellow;
        border: 1px solid;
        padding: 50px;
      }
    </style>
  </head>
  <body>
    <div id="myDiv2">
      <p id="myP2">点击该段落， 我是冒泡</p>
    </div>
    <br />
    <script>
      document.getElementById('myP2').addEventListener('click', function() {
        alert('你点击了 P 元素!')
        event.stopImmediatePropagation()
      })
      document.getElementById('myP2').addEventListener('click', function() {
        alert('你点击了 P2 元素!')
      })
      document.getElementById('myDiv2').addEventListener('click', function() {
        alert('你点击了 DIV 元素!')
      })
    </script>
  </body>
</html>
```

<html>
<head>
<meta charset="utf-8">
<title>JSChen</title>
<style>
#myDiv2{
    background-color: yellow;
    border: 1px solid;
    padding: 50px;
}
</style>
</head>
  <body>
    <div id="myDiv2">
      <p id="myP2">点击该段落， 我是冒泡</p>
    </div><br>
    <script>
      document.getElementById("myP2").addEventListener("click", function() 
      {
        alert("你点击了 P 元素!");
        event.stopImmediatePropagation()
      });
      document.getElementById("myP2").addEventListener("click", function() 
      {
        alert("你点击了 P2 元素!");
      });
      document.getElementById("myDiv2").addEventListener("click", function()
      {
        alert("你点击了 DIV 元素!");
      });
    </script>
  </body>
</html>

指定元素 myP ，阻止了向外层冒泡，并且阻止了剩下的一个绑定事件

#### 事件代理

把子组件需要触发的相同事件注册在父节点上

## js

### 模块化

#### with

```js
function foo(obj1, obj2) {
  with (obj2) {
    console.log(obj1)
  }
}
foo('obj1', { obj1: 'obj2' })
foo('obj1', {})
```

with 指定的对象是作为作用域链的顶端

如果 with 执行块中只是用了指定对象的变量，那么减少了作用域链查找的长度

如果 with 执行块中用了作用域链上非顶端的变量，那么会加长了作用域链查找的长度

#### node module.exports exports Common.js

可以这样理解：

在当前作用域提供了两个变量，module 和 exports

module.exports 和 exports 指向的是同一个对象地址

而最终 require 导入的是 module.exports

```js
// node.js
exports = { name: 'ccc' }
console.log(module.exports)
console.log(require('./node.js'))
// {}
// {}
```

exports 得到了一个新对象的地址，module.exports 指向的对象没有更改，require 导入的永远都是 module.exports

```js
// node.js
exports.name = 'ccc'
console.log(module.exports)
console.log(require('./node.js'))
// {name:'ccc'}
// {name:'ccc'}
```

exports 地址指向的对象添加了新的属性，module.exports 指向的对象发生了更改，require 导入的永远都是 module.exports

```js
// node.js
exports.name = 'ccc'
module.exports = 1
console.log(module.exports)
console.log(require('./node.js'))
// 1
// 1
```

exports 地址指向的对象添加了新的属性，module.exports 得到了一个新的值，require 导入的永远都是 module.exports

#### es6 export export default

特点：静态分析，运行时不允许外部对引入的接口进行更改，当然接口的属性是可以修改的

::: 提示
import 会自动提升
:::

##### 1. export import

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
import { a, b } from './a.js'
```

上面 a.js 的导出，是导出指定名称的接口，不是值

而 b.js 是通过 {} 导入指定命名接口

##### 2. export import \*

整体加载

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
import * as a from './a.js'
console.log(a.a, 'a.a')
console.log(a.b, 'a.b')
```

##### 3. export default

默认输出，一个模块只能有一个默认输出

> 本质上，export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。

```js
// a.js
export default function() {
  console.log('export defalut')
}
// b.js
import mode from './a.js'
console.log(mode)
```

export default 和 export 可以同时存在

```js
// a.js
export var a = 1
var b = 2
export { b }

export default function() {
  console.log('export defalut')
}

// b.js
import mode, { a, b } from './a.js'
console.log(mode, a, b)

// b.js
import mode from './a.js'
import { a, b } from './a.js'
console.log(mode, a, b)
```

##### 4. export from

export 和 import 的复合写法，先输入后输出

```js
// a.js
export var a = 1
var b = 2
export { b }

// b.js
export { a, b } from './a.js'
```

##### 4. 跨模块常量小技巧

目录结构

- other.js
- constants
  - config.js
  - wx.js
  - index.js

常量分文件，再由 index 做转发

```js
// config.js
export const config = {
  baseUrl: 'https://blog.jschen.cc',
  port: '8080'
}
```

```js
// wx.js
export const wx = {
  appID: 1231231231231,
  Key: 12313123131
}
```

```js
// index.js
export { config } from './config.js'
export { wx } from './wx.js'
```

其他模块引入常量

```js
// other.js
import { config, wx } from './constants/index.js'
```

#### es2020 提案 import() 动态加载

```js
const main = document.querySelector('main')

import(`./section-modules/${someVariable}.js`)
  .then(module => {
    module.loadPageInto(main)
  })
  .catch(err => {
    main.textContent = err.message
  })
```

> 这里直接抄阮一峰老师的[es6](https://es6.ruanyifeng.com/#docs/module#import)

#### 区别

|      | es6 import                                                     | node require                             | es2020 import()                                       |
| ---- | -------------------------------------------------------------- | ---------------------------------------- | ----------------------------------------------------- |
| 特点 | 静态分析                                                       | 动态加载                                 | 动态加载                                              |
| 区别 | 编译时处理，所有无法实现运行时的动态加载，所以有一个提升的效果 | 到底加载的哪个模块，只有运行的时候才知道 | 运行是执行到哪就加载到哪，返回的是一个 `Promise` 对象 |

### 执行栈

### 原型链

### 闭包

### this

### new

### apply,cell,bind

#### apply

es6

```js
Function.jschenApply = function(context, arr) {
  context.fn = this
  return context.fn(...arr)
}
```

es3

```js
Function.jschenApply = function(context, arr) {
  context.fn = this
  let args
  for (let i = 0; i < arr.length; i += 1) {
    args.push('arr[' + i + ']')
  }
  let result = eval('context.fn(' + args + ')')
  delete context.fn
  return result
}
```

::: 重点

1. context 添加一个新的属性 fn ，让函数的 this 指向，context

2. 用 for 遍历 arr ,生成一个数组，元素为字符串型的引用语句，例如： 'arr[1]'

3. 使用 eval 函数执行函数

4. delete context.fn

5. 返回结果
   :::

#### call

```js
Function.prototype.jschenCall = function(context) {
  context = context || window
  context.fn = this
  let result
  let args
  for (let i = 0; i < arguments.length; i += 1) {
    if (!i) return
    args.push('arguments[' + i + ']')
  }
  result = eval('context.fn(' + args + ')')
  delete context.fn
  return result
}
```

::: 重点

1. context 添加一个新的属性 fn ，让函数的 this 指向，context

2. 用 for 遍历 arguments ,生成一个数组，元素为字符串型的引用语句，例如： 'arguments[1]'

3. 使用 eval 函数执行函数

4. delete context.fn

5. 返回结果
   :::

#### bind

es3 简易版

```js
Function.prototype.jschenBind = function(context) {
  let self = this
  let args1 = Array.prototype.slice.call(arguments, 1)
  return function() {
    let args2 = Array.prototype.slice.call(arguments)
    return self.apply(context, args1.concat(args2))
  }
}
```

::: 重点

1. 把函数存为变量 self

2. 拿到剩余参数

3. 拿到参数

4. 使用 apply 执行函数

5. 返回结果
   :::

### event-loop

| 宏任务                | 浏览器 | node | 备注                               |
| --------------------- | ------ | ---- | ---------------------------------- |
| setTimeout            | ✅     | ✅   |                                    |
| setInterval           | ✅     | ✅   |                                    |
| setImmediate          | ❌     | ✅   |                                    |
| requestAnimationFrame | ✅     | ❌   | 请求下次重绘前调用回调函数更新动画 |
| I/O                   | ✅     | ✅   |                                    |

| 微任务           | 浏览器 | node | 备注                      |
| ---------------- | ------ | ---- | ------------------------- |
| process.nextTick | ❌     | ✅   |                           |
| promise          | ✅     | ✅   |                           |
| MutationObserver | ✅     | ❌   | 监听指定 dom 更改后的回调 |

### cookie localStorage sessionStorage indexDB

| 特性         | cookie                                     | localStorage             | sessionStorage | indexDB                  |
| ------------ | ------------------------------------------ | ------------------------ | -------------- | ------------------------ |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间         | 除非被清理，否则一直存在 | 页面关闭就清理 | 除非被清理，否则一直存在 |
| 数据存储大小 | 4K                                         | 5M                       | 5M             | 无限                     |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与                   | 不参与         | 不参与                   |




### Service Worker

用于浏览器缓存，vue 文档就有用

具体看这篇博文[前端进阶之道](https://www.yuchengkai.cn/docs/frontend/browser.html#service-worker)

### react vue 的区别

### webpack 的生命周期

### webpack 的 loader 和 plugin 阶段那个更耗时

### 如何用 var 实现 let const

### 防抖 节流

#### 防抖

```js
function debounce(fn, time, immediate) {
  let timer = null
  let result
  return function(...val) {
    clearTimeout(timer)
    if (immediate) {
      if (!timer) {
        result = fn.apply(this, val)
      }
      timer = setTimeout(() => {
        timer = null
      }, time * 1000)
    } else {
      timer = setTimeout(() => {
        result = fn.apply(this, val)
      }, time * 1000)
    }
    return result
  }
}
```

#### 节流

简单版本

```js
function throttle(fn, s) {
  let result
  let start = 0
  return function(...val) {
    if (+new Date() > start + s * 1000) {
      result = fn.apply(this, val)
      start = +new Date()
    }
    return result
  }
}
```

### promise

Promise 是 ES6 新增的语法，解决了回调地狱的问题。

### Proxy

代理

```js
var obj = new Proxy(
  {},
  {
    get: function(target, propKey, receiver) {
      console.log(`getting ${propKey}!`)
      return Reflect.get(target, propKey, receiver)
    },
    set: function(target, propKey, value, receiver) {
      console.log(`setting ${propKey}!`)
      return Reflect.set(target, propKey, value, receiver)
    }
  }
)
obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
```

### 垃圾回收

v8 采用的是标记清除算法和标记压缩算法

v8 将内存（堆）分为新生代和老生代两部分

### 设计模式

#### 工厂模式

#### 单例模式

#### 发布订阅

#### 代理模式

###

## vue

### 响应式原理

利用了 object.definedProperty 实现一个观察者，和数据代理

再通过一个发布订阅模式，在数据更改时通知所有订阅者，在初始化订阅者的时候把当前订阅者缓存起来，并且强制执行监听器的 get 函数

再来一个订阅器做保存当前订阅者用

匹配 `{{}}` 实现一个编译器


### 路由

三种

- hash
- history
- abstract

#### hash

- hash 其实就是锚点，跳转到锚点指定的位置而不会真的跳转页面

- 通过监听 hashchange 做页面更换处理

#### history

- 利用 html5 history 维护一个页面栈

- 路由跳转实际上并不是真的跳转页面，需要在服务端配置重定向

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="jschen"></div>
  <ul>
    <li href="/cc1">ccc1</li>
    <li href="/cc2">ccc2</li>
    <li href="/cc3">ccc3</li>
  </ul>
</body>
<script>
  class Router {
    constructor(){
      this.router = {}
    }
    push(url,query){
      history.pushState({query},'title_cc1',url)
      this.router[url] && this.router[url]()
    }
    replace(url,query){
      history.replaceState({query,},'title_cc1',url)
      this.router[url] && this.router[url]()
    }
    init(...val){
      this.replace(...val)
    }
    setConfig(optionList){
      optionList.forEach(pageOption => {
        this.router[pageOption.router] = pageOption.cb // 这个cb就是用来切换页面的 
      });
    }
  }
  let router = new Router()
  router.setConfig([
    {
      router:'/html.html',
      cb:() => {console.log('加载主页')}
    },
    {
      router:'/cc1',
      cb:() => {console.log('加载cc1')}
    },
    {
      router:'/cc2',
      cb:() => {console.log('加载cc2')}
    },
    {
      router:'/cc3',
      cb:() => {console.log('加载cc3')}
    }
  ])
  router.init(location.pathname,{name:'我是主页'}) // 这里很重要哈，因为history模式下跳转的页面实际上是不存在的，如果用户在其他路由下刷新页面那么nginx接到的请求页面是找不到的，所以这里需要在nginx配置重定向
  document.querySelector('ul').addEventListener('click',(e) => {
    console.log(e,'e');
    e.preventDefault()
    console.log(e.target.getAttribute('href'));
    
    router.push(e.target.getAttribute('href'),{name:'asdf'})
  })
</script>
</html>
```


#### abstract

这个是在 node.js 跑的

## nuxt

### 浏览器渲染和服务端渲染的区别

## tcp/ip

### 状态码

#### 永久重定向和临时重定向的区别

301 永久
302 临时
304 未修改，直接拿缓存

401 未授权
404 找不到
412 未满足前提条件

500 服务端错误

### http 缓存类型 ssl 加密

### http 和 https 的区别

node 服务器实现 http2

拉一个 node-http2 模块

```js
```

### https 配置安全证书 ssl 流程

首先介绍一下两个端口， 一个是 80 端口，一个是 443 端口

443 ： 网页浏览端口，主要是用于 HTTPS 服务，是提供加密和通过安全端口传输的另一种 HTTP。

80 ： 用于网页浏览。木马 Executor 开放此端口

#### 用 node 做服务端，配置 ssl 流程

1. 到阿里云申请 ssl 证书
2. 下载 ssl 证书 nginx 版就可以，key 文件和 pem 文件
3. node 创建 https 文件，放入 key 文件和 pem 文件

```js
const express = require('express')
const http = require('http')
const https = require('https')
const fs = require('fs')
// Configuare https
const httpsOption = {
  key: fs.readFileSync('./https/xxxxxxxxxxxx.key'),
  cert: fs.readFileSync('./https/xxxxxxxxxxxx.pem')
}
// Create service
const app = express()

http.createServer(app).listen(80)
https.createServer(httpsOption, app).listen(443)
```

### [从输入 URL 到页面加载发生了什么](https://segmentfault.com/a/1190000006879700)

- 重定向
- 拉取缓存
- DNS 查询
- 建立 TCP 链接
- 发起请求
- 接收响应
- 处理 HTML 元素
- 元素加载完成

### 跨域

## node

### cors

node 设置 cors

```js
app.use(function(req, res, next) {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE,OPTION')
  res.header('Access-Control-Allow-Headers', 'content-type,Origin,Accept,X-Requested-with,Access-Control-Allow-Credentials')
  res.header('Access-Control-Allow-Credentials', true)
  if (req.method == 'OPTION') {
    res.send(200)
  } else {
    next()
  }
})
```

## webpack

## CI/CD

## 测试

### 单元测试

### 端对端测试

## 性能优化

- window.serviceWorker 缓存文件

- 越是具体的 CSS 选择器，执行速度越慢

- 频繁的单独生成图层
  - 3D 变换：translate3d、translateZ
  - will-change
  - video、iframe 标签
  - 通过动画实现的 opacity 动画转换
  - position: fixed

- 减少重绘和回流[前端进阶之道](https://www.yuchengkai.cn/docs/frontend/browser.html#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81)

- DNS 预解析[MDN  X-DNS-Prefetch-Control](https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching)
- 强缓存和协商缓存
- http2.0
- webpack 设置 tree shaking 移除没有用的代码

## 安全




## 如何封装树状菜单

## 封装继承多态

```js
var a = 9
function fn() {
  a = 0
  return function(b) {
    return b + a++
  }
}

var f = fn()
console.log(f(5))
console.log(fn()(5))
console.log(f(5))
console.log(a)
```

## 同源策略，跨域规避方案

### 一、一级域名相同 -- 拿 `cookie`

`A` 网页 `https://xiaoai.dankal.cn` ， `B` 网页 `https://xiaoai-admin.dankal.cn` ， `C` 网页 `https://dankal.cn` ， `AB` 网页都是二级域名 ， `C` 网页是顶级域名

3 个分别窗口访问 `A` 、 `B` 、 `C` ， 或者 互相嵌入 `iframe`

通过设置 `cookie` 规避跨域

```js
// 在任意页面
document.cookie = "test=i'm test cookie;domain=dankal.cn"
```

```js
// 在任意页面
document.cookie
// test=i'm test cookie
```

### 二、 一级域名相同 -- 内嵌 `iframe` -- 拿 `DOM`

`A` 网页 `https://xiaoai.dankal.cn` ， `iframe` 页面 `https://xiaoai-admin.dankal.cn` ，

设置 `A` 页面和 `iframe` 页面的 `domain` 为顶级域名 `dankal.cn`

```js
//  `A` 页面和 `iframe` 页面
document.domain = 'dankal.cn'
```

```js
// `A` 页面
document.getElementById('iframeId').contentWindow.document
// # document
```

```js
// iframe 页面
window.parent.document
// # document
```

### 三、 postMessage

父亲向子发消息

```js
// 父窗口
var jschenP = window.open('https://www.baidu.cn')
jschenP.postMessage('hello baidu', 'https://www.baidu.cn')

// 百度
window.addEventListener('message', function(event) {
  console.log(event.data) // 消息内容
  console.log(event.origin) // 发消息的网站
  console.log(event.source) // 发消息的窗口
})
```

子向父亲发消息

```js
// 父窗口 https://blog.jschen.cc
var jschenP = window.open('https://www.baidu.cn')
window.addEventListener('message', function(event) {
  console.log(event.data) // 消息内容
  console.log(event.origin) // 发消息的网站
  console.log(event.source) // 发消息的窗口
})

// 百度
window.opener.postMessage('hello father', 'https://blog.jschen.cc')
```

### 四、ajax 请求 jsonp ， websocket ， cors

#### jsonp

```js
function foo(data) {
  console.log(data, '成功拿到数据了')
}
function getApi(src) {
  let script = document.createElement('script')
  script.src = src
  document.body.appendChild(script)
}
window.onload = function() {
  getApi('https://www.baidu.com?callback=foo')
}
```

#### webSocket

使用 ws wss 协议标识符，在 tcp 协议上进行全双工通讯

这里偷偷摘了阮一峰老师[WebSocket](http://www.ruanyifeng.com/blog/2017/05/websocket.html)的 wss 地址

```js
var websocket = new WebSocket('wss://echo.websocket.org')

websocket.onopen = function(evt) {
  console.log('Connection 开了 ...')
  websocket.send('Hello WebSockets!')
}

websocket.onmessage = function(evt) {
  console.log('Received 接受到的消息: ' + evt.data)
  this.send(evt.data)
}

websocket.onclose = function(evt) {
  console.log('Connection closed.')
}

websocket.send('我是 JSChen！')
```

#### node 设置 cors

```js
app.use('*', (req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*')
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTION')
  res.header('Access-Control-Allow-Headers', 'content-type,Cache-Control,Access-Control-Allow-Credentials')
  res.header('Access-Control-Allow-Credentials', true)
  if (req.methods == 'OPTION') {
    res.send(200)
  } else {
    next()
  }
})
```


